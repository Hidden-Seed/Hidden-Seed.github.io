[{"title":"è®¡ç®—æœºä½“ç³»ç»“æ„ï¼ˆä¸€ï¼‰-é‡åŒ–åˆ†æä¸è®¾è®¡åŸºç¡€","url":"/posts/2815a773/","content":"ç¬¬ä¸€ç«   é‡åŒ–åˆ†æä¸è®¾è®¡åŸºç¡€1. ä½“ç³»ç»“æ„çš„å¤å…´æ‘©å°”å®šå¾‹ï¼šæ™¶ä½“ç®¡æ•°é‡çš„æŒ‡æ•°çº§å¢é•¿ï¼ˆå·²ç»ˆç»“ï¼‰\nç™»çº³å¾·ç¼©æ”¾æ¯”ä¾‹å®šå¾‹ï¼šåŠŸç‡å¯†åº¦çš„æ’å®šï¼ˆå·²ç»ˆç»“ï¼‰\nä½“ç³»ç»“æ„\næŒ‡ä»¤é›†è®¾è®¡ï¼ˆä¸åŒ…å«å®ç°ï¼‰$\\rightarrow$ ç»„æˆ+ç¡¬ä»¶\n\næŠ€æœ¯è¶‹åŠ¿ï¼š1. å¸¦å®½èƒœè¿‡å»¶è¿Ÿï¼›2. è¿çº¿çš„å›°éš¾ã€‚\næŒ‡ä»¤çº§å¹¶è¡Œ$\\rightarrow$æ•°æ®çº§å¹¶è¡Œ$\\rightarrow$çº¿ç¨‹çº§å¹¶è¡Œ\n2. é‡åŒ–åˆ†ææ–¹æ³•2.1 åŠŸè€—ï¼ˆPowerï¼‰ä¸èƒ½è€—ï¼ˆEnergyï¼‰\n\\text{Energy}_\\text{dynamic} \\propto 1/2 \\times \\text{Capacitive load} \\times \\text{Voltage}^{2}\n\\text{Power}_\\text{dynamic} \\propto 1/2 \\times \\text{Capacitive load} \\times \\text{Voltage}^{2} \\times \\text{Frequency switched}\n\\text{Power}_\\text{static} \\propto \\text{Current}_\\text{static} \\times \\text{Voltage}\nDo nothing well\nDynamic voltage-frequency scaling (DVFS)\nDesign for the typical case\nOverclocking\n\n2.2 æˆæœ¬æ—¶é—´ã€äº§é‡ã€å¤§ä¼—åŒ–\né›†æˆç”µè·¯çš„æˆæœ¬\n\n\\text{wafer} \\xrightarrow{\\text{tested and chopped}} \\text{die}\n\\text{Cost of integrated circuit} = \\frac{\\text{Cost of die} + \\text{Cost of testing die} + \\text{Cost of packaging and final test}}{\\text{Final test yield}}\n\\text{Cost of die} = \\frac{\\text{Cost of wafer}}{\\text{Dies per wafer} \\times \\text{Die yield}}\n\\text{Dies per wafer} = \\frac{\\pi \\times {(\\text{Wafer diameter}/2)}^2}{\\text{Die area}} - \\frac{\\pi \\times \\text{Wafer diameter}}{\\sqrt{\\pi \\times \\text{Die area}}}\n\\text{Die yield} = \\text{Wafer yield} \\times (1 + \\text{Defects per unit area} \\times \\text{Die area})^{N}åˆ¶é€ å·¥è‰ºå†³å®šäº†æ™¶åœ†æˆæœ¬ã€æ™¶åœ†è‰¯ç‡å’Œ  å•ä½é¢ç§¯ä¸Šçš„ç¼ºé™·æ•°ï¼Œæ‰€ä»¥è®¾è®¡äººå‘˜å”¯ä¸€èƒ½å¤Ÿæ§åˆ¶çš„å°±æ˜¯æ™¶ç‰‡é¢ç§¯ã€‚\n\n2.3 å¯ä¿¡ä»»åº¦2.3.1 æ¨¡å—å¯é æ€§ï¼ˆModule reliabilityï¼‰å¹³å‡æ— æ•…éšœæ—¶é—´ï¼ˆmean time to failure, MTTFï¼‰\næ•…éšœç‡ï¼ˆrate of failure = 1/MTTFï¼‰ï¼šé€šå¸¸ä»¥è¿è¡Œ10äº¿å°æ—¶å‘ç”Ÿçš„ æ•…éšœæ•°æ¥è¡¨ç¤ºï¼Œè¢«ç§°ä¸ºFITï¼ˆfailures in timeï¼‰\n\n1\\, \\text{FIT} = 1\\, \\text{failure per } 10^9 \\text{ hours}\n\\lambda \\text{(failures/hour)} = \\frac{\\text{FIT}}{10^9}\n\\text{FIT} = \\lambda \\times 10^9 = \\frac{10^9}{\\text{MTTF}}å¹³å‡ä¿®å¤æ—¶é—´ï¼ˆmean time to repair, MTTRï¼‰\nå¹³å‡æ•…éšœé—´éš”æ—¶é—´ï¼ˆmean time between failures, MTBFï¼‰= MTTF + MTTR\nå¦‚æœä¸€ç»„æ¨¡å—çš„ç”Ÿå­˜æœŸå‘ˆæŒ‡æ•°åˆ†å¸ƒï¼Œä¹Ÿå°±æ˜¯è¯´æ¨¡å—çš„è€åŒ–å¯¹äºæ•…éšœæ¦‚ç‡çš„å½±å“ä¸å¤§ï¼Œé‚£ä¹ˆã€Œè¿™ä¸€ç»„æ¨¡å—çš„æ•´ä½“æ•…éšœç‡å°±æ˜¯è¿™äº›æ¨¡å—çš„  æ•…éšœç‡ä¹‹å’Œã€ã€‚\nä¸€ä¸ªæ¨¡å—çš„å¯¿å‘½ $T$ æœä»æŒ‡æ•°åˆ†å¸ƒï¼š\n\nf(t) = \\lambda e^{-\\lambda t}, \\quad t \\ge 0å…¶ä¸­ $\\lambda$ æ˜¯æ•…éšœç‡ï¼ˆfailure rateï¼‰ã€‚\næŒ‡æ•°åˆ†å¸ƒçš„ç‰¹ç‚¹ï¼šæ— è®°å¿†æ€§ï¼ˆmemorylessï¼‰\n\nP(T > t + s \\mid T > s) = P(T > t)å‡è®¾ç³»ç»Ÿä¸­æœ‰ $n$ ä¸ªæ¨¡å—ï¼Œå®ƒä»¬ç›¸äº’ç‹¬ç«‹ï¼Œä¸”å¯¿å‘½éƒ½æœä»æŒ‡æ•°åˆ†å¸ƒï¼š\n\n\\text{æ¨¡å— } i: f_i(t) = \\lambda_i e^{-\\lambda_i t}ç³»ç»Ÿåœ¨ã€Œä»»ä¸€æ¨¡å—å¤±æ•ˆã€æ—¶å°±ç®—ç³»ç»Ÿå¤±æ•ˆï¼ˆå³ä¸²è”ç³»ç»Ÿï¼‰ã€‚\nç³»ç»Ÿå¯é æ€§å‡½æ•°ï¼ˆå³â€œç³»ç»Ÿå­˜æ´»åˆ° t çš„æ¦‚ç‡â€ï¼‰ä¸ºï¼š\n\nR_{\\text{sys}}(t) = e^{-(\\lambda_1 + \\lambda_2 + \\cdots + \\lambda_n)t}è¿™ä»ç„¶æ˜¯ä¸€ä¸ªæŒ‡æ•°åˆ†å¸ƒï¼Œå‚æ•°æ˜¯æ‰€æœ‰æ¨¡å— Î» çš„å’Œã€‚\nç³»ç»Ÿæ•…éšœç‡ç”±ä¸Šå¼å¯å¾—ï¼š\n\n\\lambda_{\\text{sys}} = \\lambda_1 + \\lambda_2 + \\cdots + \\lambda_n2.3.2 æ¨¡å—å¯ç”¨æ€§ï¼ˆ Module availabilityï¼‰\n\\text{Module availability} = \\frac{\\text{MTTF}}{\\text{MTTF} + \\text{MTTR}}2.3.3 ä¸€ä¸ªä¾‹å­ç£ç›˜å­ç³»ç»Ÿç»å¸¸å¤‡æœ‰å†—ä½™ç”µæºï¼Œä»¥æé«˜å¯ä¿¡ä»»åº¦ã€‚å‡è®¾ä¸€ä¸ªç”µæºè¶³ä»¥è¿è¡Œç£ç›˜å­ç³»ç»Ÿï¼Œè€Œä¸”æˆ‘ä»¬è¦æ·»åŠ ä¸€ä¸ªå†—ä½™ç”µæºã€‚ \næˆ‘ä»¬éœ€è¦ä¸€ä¸ªå…¬å¼æ¥è¡¨æ˜å½“å¯ä»¥å®¹å¿ä¸€ä¸ªæ•…éšœå¹¶ä»èƒ½æä¾›æœåŠ¡æ—¶çš„æƒ…æ™¯ã€‚ä¸ºäº†ç®€åŒ–è®¡ç®—ï¼Œå‡å®šç»„ä»¶çš„ç”Ÿå­˜æœŸå‘ˆæŒ‡æ•°åˆ†å¸ƒï¼Œè€Œä¸”ç»„ä»¶æ•…éšœä¹‹é—´æ²¡æœ‰ç›¸å…³æ€§ã€‚\nå†—ä½™ç”µæºå¯¹çš„MTTFå°±æ˜¯ä¸¤ä¸ªé‡çš„æ¯”å€¼ï¼Œåˆ†å­æ˜¯ä»åˆå§‹æ—¶åˆ»åˆ°ä¸€ä¸ªç”µæºå‘ç”Ÿæ•…éšœçš„å¹³å‡æ—¶é—´ï¼Œ åˆ†æ¯æ˜¯åœ¨æ›´æ¢ç¬¬ä¸€ä¸ªç”µæºä¹‹å‰å¦ä¸€ä¸ªç”µæºä¹Ÿå‘ç”Ÿæ•…éšœçš„æ¦‚ç‡ã€‚\n\nå› æ­¤ï¼Œå¦‚æœåœ¨ä¿®å¤ç¬¬  ä¸€ä¸ªæ•…éšœä¹‹å‰å‘ç”Ÿç¬¬äºŒä¸ªæ•…éšœçš„å¯èƒ½æ€§å¾ˆå°ï¼Œé‚£ä¹ˆç”µæºå¯¹çš„MTTFå°±å¾ˆå¤§ã€‚ ç”±äºæˆ‘ä»¬æœ‰ä¸¤ä¸ªç”µæºï¼Œè€Œä¸”æ•…éšœç‹¬ç«‹ï¼Œæ‰€ä»¥åœ¨ä¸€ä¸ªç”µæºå‘ç”Ÿæ•…éšœä¹‹å‰çš„å¹³å‡æ—¶é—´ä¸º$\\text{MTTF}_\\text{ç”µæº} / 2$ã€‚å‘ç”Ÿç¬¬äºŒä¸ªæ•…éšœçš„æ¦‚ç‡æœ‰ä¸€ä¸ªå¾ˆå¥½çš„è¿‘ä¼¼ï¼šç”¨MTTRé™¤ä»¥å¦ä¸€ä¸ªç”µæº  å‘ç”Ÿæ•…éšœä¹‹å‰çš„å¹³å‡æ—¶é—´ã€‚å› æ­¤ï¼Œå†—ä½™ç”µæºå¯¹çš„åˆç†è¿‘ä¼¼ä¸ºï¼š\n\n\\text{MTTF}_{\\text{power supply pair}} = \\dfrac{\\text{MTTF}_{\\text{power supply}}/2}{\\dfrac{\\text{MTTR}_{\\text{power supply}}}{\\text{MTTF}_{\\text{power supply}}}} = \\dfrac{\\text{MTTF}_{\\text{power supply}}^2 / 2}{\\text{MTTR}_{\\text{power supply}}} = \\dfrac{\\text{MTTF}_{\\text{power supply}}^2}{2 \\times \\text{MTTR}_{\\text{power supply}}}$\\text{MTTF}{\\text{power supply}} = 2000 \\text{ h}$ï¼Œ$\\text{MTTR}{\\text{power supply}} = 24 \\text{ h}$ï¼Œåˆ™ $\\text{MTTF}_{\\text{power supply pair}} \\approx 833 333 333 \\text{ h}$ï¼Œæé«˜çº¦4150å€\n2.4 æ€§èƒ½\nn = \\cfrac{\\text{Execution time}_{Y}}{\\text{Execution time}_{X}} = \\dfrac{\\dfrac{1}{\\text{Performance}_{Y}}}{\\dfrac{1}{\\text{Performance}_{X}}} = \\dfrac{\\text{Performance}_{X}}{\\text{Performance}_{Y}} SPECåŸºå‡†æµ‹è¯•ï¼šSPEC - Standard Performance Evaluation Corporation\næ¡Œé¢åŸºå‡†æµ‹ã€æœåŠ¡å™¨åŸºå‡†æµ‹è¯•\nSPECRatioï¼šå°†åŸºå‡†è®¡ ç®—æœºä¸Šçš„æ‰§è¡Œæ—¶é—´é™¤ä»¥å¾…è¯„ä¼°è®¡ç®—æœºä¸Šçš„æ‰§è¡Œæ—¶é—´ï¼Œå¾—åˆ°ä¸€ä¸ªä¸æ€§èƒ½æˆæ­£æ¯”çš„æ¯”å€¼ã€‚\nå¯¹äºæ¯ä¸ªåŸºå‡†ç¨‹åº $i$ï¼Œå®šä¹‰ï¼š\n\n\\text{SPECRatio}_i = \\frac{\\text{Reference Time}_i}{\\text{Test System Time}_i}\n\\text{SPECint (æˆ– SPECfp)} = \\left( \\prod_{i=1}^{n} \\text{SPECRatio}_i \\right)^{1/n}å‡ ä½•å¹³å‡å€¼ä¹‹æ¯”ç­‰äºæ€§èƒ½æ¯”å€¼çš„å‡ ä½•å¹³å‡å€¼ï¼Œä¸”$\\text{SPECRatio}$åŸºå‡†è®¡ç®—æœºçš„é€‰æ‹©æ— å…³ç´§è¦ã€‚\n\n\\dfrac{\\text{Geometric mean}_\\text{A}}{\\text{Geometric mean}_\\text{B}} = \\dfrac{\\sqrt[n]{\\displaystyle \\prod_{i=1}^{n} \\text{SPECRatio A}_i}}{\\sqrt[n]{\\displaystyle \\prod_{i=1}^{n} \\text{SPECRatio B}_i}} = \\sqrt[n]{\\prod_{i=1}^{n} \\dfrac{\\text{SPECRatio A}_i}{\\text{SPECRatio B}_i}}\n = \\sqrt[n]{\\prod_{i=1}^{n} \\dfrac{\\dfrac{\\text{Execution time}_{\\text{reference}_i}}{\\text{Execution time}_{\\text{A}_i}}}{\\dfrac{\\text{Execution time}_{\\text{reference}_i}}{\\text{Execution time}_{\\text{B}_i}}}} = \\sqrt[n]{\\prod_{i=1}^{n} \\dfrac{\\text{Execution time}_{\\text{B}_i}}{\\text{Execution time}_{\\text{A}_i}}} = \\sqrt[n]{\\prod_{i=1}^{n} \\dfrac{\\text{Performance}_{\\text{B}_i}}{\\text{Performance}_{\\text{A}_i}}}\n3. è®¡ç®—æœºè®¾è®¡çš„é‡åŒ–åŸç†\næé«˜å¹¶è¡Œæ€§\nå±€éƒ¨æ€§åŸç†ï¼ˆç©ºé—´å±€éƒ¨+æ—¶é—´å±€éƒ¨ï¼‰\né‡ç‚¹å…³æ³¨å¸¸è§æƒ…å½¢\n\n3.1 Amdahlâ€˜s LawåŠ é€Ÿæ¯”ï¼ˆSpeedupï¼‰\n\n\\text{Speedup} = \\dfrac{\\text{Performance for entire task using the enhancement when possible}}{\\text{\nPerformance for entire task without using the enhancement}}\n\\text{Speedup} = \\dfrac{\\text{Execution time for entire task without using the enhancement}}{\\text{Execution time for entire task using the enhancement when possible\n}}åŠ é€Ÿæ¯”å–å†³äºä¸‹é¢ä¸¤ä¸ªå› ç´ ï¼š\n\nåŸè®¡ç®—æœºè®¡ç®—æ—¶é—´ä¸­å¯æ”¹è¿›éƒ¨åˆ†æ‰€å çš„æ¯”ä¾‹ï¼šæ”¹è¿›æ¯”ä¾‹ï¼ˆ$\\text{Fraction}_\\text{enhanced}$ï¼‰ï¼Œå°äºæˆ–ç­‰äº1ã€‚\né€šè¿‡æ”¹è¿›æ‰§è¡Œæ¨¡å¼å¾—åˆ°çš„æ”¹è¿›ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨ä¸ºæ•´ä¸ªç¨‹åºä½¿ç”¨è¿™ä¸€æ‰§è¡Œæ¨¡å¼æ—¶ï¼Œä»»åŠ¡çš„è¿è¡Œé€Ÿåº¦ä¼šæé«˜å¤šå°‘å€ï¼šæ”¹è¿›åŠ é€Ÿæ¯”ï¼ˆ$\\text{Speedup}_\\text{enhanced}$ï¼‰ï¼Œå¤§äº1ã€‚\n\n\n\\text{Execution time}_\\text{new} = \\text{Execution time}_\\text{old} \\times \\left ( (1 - \\text{Fraction}_\\text{enhanced}) + \\dfrac{\\text{Fraction}_\\text{enhanced}}{\\text{Speedup}_\\text{enhanced}} \\right )\n\\text{Speedup}_\\text{overall} = \\dfrac{\\text{Execution time}_\\text{old}}{\\text{Execution time}_\\text{new}} = \\dfrac{1}{(1 - \\text{Fraction}_\\text{enhanced}) + \\dfrac{\\text{Fraction}_\\text{enhanced}}{\\text{Speedup}_\\text{enhanced}}}3.2 å¤„ç†å™¨æ€§èƒ½å…¬å¼ç¨‹åºçš„CPUæ—¶é—´è¡¨ç¤ºï¼š\n\n\\text{CPU time} = \\text{CPU clock cycles for a program} \\times  \\text{Clock cycle time}\n\\text{CPU time} = \\dfrac{\\text{CPU clock cycles for a program}}{\\text{Clock rate}}æŒ‡ä»¤è·¯å¾„é•¿åº¦æˆ–æŒ‡ä»¤æ•°ï¼ˆinstruction count, ICï¼‰ï¼šè®¡ç®—æ‰€æ‰§è¡Œçš„æŒ‡ä»¤æ•°ã€‚\næ¯æ¡æŒ‡ä»¤çš„æ—¶é’Ÿå‘¨æœŸæ•°ï¼ˆclock cycles per instruction, CPIï¼‰çš„å¹³å‡å€¼ï¼š\n\n\\text{CPI} = \\dfrac{\\text{CPU clock cycles for a program}}{\\text{Instruction count}}\n \\text{Clock cycles} = \\text{IC} \\times \\text{CPI}\n\\text{CPU time} = \\text{Instruction count} \\times \\text{Cycles per instruction} \\times \\text{Clock cycle time}\n= \\dfrac{\\text{Instructions}}{\\text{Program}} \\times \\dfrac{\\text{Clock cycles}}{\\text{Instruction}} \\times \\dfrac{\\text{Seconds}}{\\text{Clock cycle}} = \\dfrac{\\text{Seconds}}{\\text{Program}}å¤„ç†å™¨æ€§èƒ½å–å†³äº3ä¸ªç‰¹æ€§ï¼šæ—¶é’Ÿå‘¨æœŸï¼ˆæˆ–æ—¶é’Ÿé¢‘ç‡ï¼‰ã€æ¯æ¡æŒ‡ä»¤çš„æ—¶é’Ÿ å‘¨æœŸæ•°å’ŒæŒ‡ä»¤æ•°ã€‚\nCPUæ—¶é—´ä¹Ÿå–å†³äºè¿™3ä¸ªç‰¹æ€§ï¼š3ä¸ªç‰¹æ€§ä¸­ä»»æ„ä¸€é¡¹æ”¹è¿›10%,  å°†ä½¿CPUæ—¶é—´æ”¹è¿›10%ã€‚\n\næ—¶é’Ÿå‘¨æœŸæ—¶é—´ï¼šç¡¬ä»¶æŠ€æœ¯ä¸ç»„æˆã€‚ \nCPIï¼šç»„æˆä¸æŒ‡ä»¤é›†ä½“ç³»ç»“æ„ã€‚\næŒ‡ä»¤æ•°ï¼šæŒ‡ä»¤é›†ä½“ç³»ç»“æ„å’Œç¼–è¯‘å™¨æŠ€æœ¯ã€‚ \n\n\n\n\\text{CPU clock cycles} = \\sum_{i=1}^{n}{\\text{IC}_i \\times \\text{CPI}_i}\n$\\text{IC}_i$ï¼šä¸€ä¸ªç¨‹åºä¸­ç¬¬iä¸ªæŒ‡ä»¤çš„æ‰§è¡Œæ¬¡æ•°ï¼›\n$\\text{CPI}_i$ï¼šç¤ºç¬¬iä¸ªæŒ‡ä»¤çš„æ¯æ¡æŒ‡ä»¤å¹³å‡æ—¶é’Ÿå‘¨æœŸæ•°ã€‚\n\n\n\\text{CPU time} = \\left( \\sum_{i=1}^{n}{\\text{IC}_i \\times \\text{CPI}_i} \\right) \\times \\text{Clock cycle time}\n\\text{CPI}_\\text{overall} = \\dfrac{\\displaystyle \\sum_{i=1}^{n}{\\text{IC}_i \\times \\text{CPI}_i}}{\\text{Instruction count}} = \\sum_{i=1}^{n}{\\dfrac{\\text{IC}_i}{\\text{Instruction count}} \\times \\text{CPI}_i} $\\text{CPI}$ çš„åä¸€ç§è®¡ç®—å½¢å¼ä½¿ç”¨äº†å„ä¸ª $\\text{CPI}_i$ ï¼Œå’Œè¯¥æŒ‡ä»¤åœ¨ä¸€ä¸ªç¨‹åºä¸­æ‰€å çš„æ¯”ä¾‹ã€‚\nAppendix AA.1 ä¸ºä»€ä¹ˆè¾ƒæ–°çš„æŒ‡ä»¤é›†éƒ½ä¸åœ¨æŒ‡ä»¤ä¸­ç›´æ¥è®¿é—®å­˜å‚¨å™¨ï¼Œè€Œæ˜¯é€šè¿‡è½½å…¥-å­˜å‚¨çš„æ–¹å¼ï¼Ÿ\nâœ… è¶Šæ–°çš„ ISAï¼ˆå¦‚ RISC-Vã€MIPSã€ARMã€SPARCï¼‰éƒ½é‡‡ç”¨ Load/Store æ¶æ„ï¼Œè€Œè€æ¶æ„ï¼ˆå¦‚ x86ã€VAXã€PDP-11ï¼‰åˆ™å¸¸å…è®¸åœ¨ä»»æ„æŒ‡ä»¤ä¸­ç›´æ¥è®¿é—®å†…å­˜ã€‚\n\nA.1.1 èƒŒæ™¯ï¼šä¸¤ç§æ¶æ„é£æ ¼\n\n\n\næ¶æ„ç±»å‹\nç‰¹ç‚¹\nä»£è¡¨\n\n\n\n\nCISCï¼ˆComplex Instruction Set Computerï¼‰\nä¸€æ¡æŒ‡ä»¤å¯ä»¥ç›´æ¥è®¿é—®å†…å­˜ã€æ‰§è¡Œå¤æ‚æ“ä½œï¼ˆå¦‚ ADD [mem1], [mem2]ï¼‰\nx86, VAX, 68000\n\n\nRISCï¼ˆReduced Instruction Set Computerï¼‰\nåªå…è®¸ä¸“é—¨çš„ Load/Store æŒ‡ä»¤è®¿é—®å†…å­˜ï¼Œè¿ç®—åªèƒ½åœ¨å¯„å­˜å™¨é—´è¿›è¡Œ\nMIPS, ARM, RISC-V\n\n\n\n\nA.1.2 ä¸ºä»€ä¹ˆç°ä»£ ISA éƒ½é‡‡ç”¨ Load/Store æ¶æ„ï¼Ÿä» ç¡¬ä»¶å®ç°ã€æ€§èƒ½ä¼˜åŒ–ã€å¹¶è¡ŒåŒ– çš„è§’åº¦ï¼Œè¿™æ˜¯å¿…ç„¶é€‰æ‹©ï¼š\n\nç®€åŒ–æµæ°´çº¿è®¾è®¡ï¼ˆPipeline-friendlyï¼‰\nåœ¨æ—©æœŸ CISC æ¶æ„ä¸­ï¼Œä¸€æ¡æŒ‡ä»¤å¯èƒ½è¦å–æ“ä½œç ã€è®¡ç®—å†…å­˜åœ°å€ã€å‘èµ·è®¿å­˜ã€å–å›æ•°æ®ã€æ‰§è¡Œç®—æœ¯ã€å†™å›ç»“æœï¼Œè¿™ä½¿å¾—ä¸€æ¡æŒ‡ä»¤çš„æ‰§è¡Œæ—¶é—´æ— æ³•é¢„æµ‹ï¼Œå¾ˆéš¾åšåˆ°æŒ‡ä»¤çº§å¹¶è¡Œï¼ˆILPï¼‰ã€‚è€Œ Load/Store æ¶æ„ä¸­ï¼ŒLoad/Store æŒ‡ä»¤åªåšè®¿å­˜ï¼›è¿ç®—æŒ‡ä»¤åªåšè®¡ç®—ã€‚æ¯ç±»æŒ‡ä»¤éƒ½æœ‰å›ºå®šæ ¼å¼å’Œæ‰§è¡Œé˜¶æ®µï¼Œæ˜“äºåˆ’åˆ†æµæ°´çº¿é˜¶æ®µï¼Œæé«˜ä¸»é¢‘ä¸ååé‡ã€‚\n\nğŸ“˜ å…¸å‹ï¼šMIPS æœ€æ—©æå‡º 5 çº§æµæ°´çº¿ (IFâ€“IDâ€“EXâ€“MEMâ€“WB)ï¼Œè‹¥ç®—æœ¯æŒ‡ä»¤èƒ½ç›´æ¥è®¿å­˜ï¼Œè¿™ä¸ªç»“æ„å°±ä¼šå®Œå…¨è¢«æ‰“ä¹±ã€‚\n\n\næ›´å®¹æ˜“ä¹±åºæ‰§è¡Œå’ŒæŒ‡ä»¤é‡æ’ï¼ˆOut-of-Order, Superscalarï¼‰\nç°ä»£ CPU è¦å¹¶è¡Œæ‰§è¡Œå¤šæ¡æŒ‡ä»¤ï¼Œéœ€è¦ç¡¬ä»¶åˆ¤æ–­ä¾èµ–å…³ç³»ã€‚ å¦‚æœæŒ‡ä»¤å¯ä»¥â€œéšæ„â€è®¿é—®å†…å­˜ï¼Œå°±å¿…é¡»åŠ¨æ€åˆ†æï¼šå“ªäº›å†…å­˜åœ°å€å¯èƒ½å†²çªï¼Ÿå“ªäº›æ•°æ®å¯èƒ½é‡å ï¼Ÿè¿™ä¼šæå¤§å¢åŠ ä¾èµ–æ£€æŸ¥é€»è¾‘å¤æ‚åº¦ã€‚\nLoad/Store æ¨¡å¼ä¸‹ï¼Œåªæœ‰ç‰¹å®šæŒ‡ä»¤è®¿é—®å†…å­˜ï¼Œä¾èµ–å…³ç³»ä¸»è¦åœ¨å¯„å­˜å™¨ä¹‹é—´ï¼Œç¡¬ä»¶èƒ½å¿«é€Ÿåˆ¤å®šå¹¶è¡Œæ€§ã€‚\n\næ˜“äºç¼–è¯‘å™¨ä¼˜åŒ–ï¼ˆCompiler-friendlyï¼‰\nåœ¨ CISC æ¶æ„ä¸‹ï¼Œç¼–è¯‘å™¨å¾ˆéš¾é¢„æµ‹å“ªäº›æŒ‡ä»¤ä¼šè®¿é—®å†…å­˜ã€‚\nåœ¨ RISC æ¶æ„ä¸­ï¼Œç¼–è¯‘å™¨èƒ½æ˜ç¡®æ§åˆ¶ï¼šä»€ä¹ˆæ—¶å€™ Loadï¼Ÿä»€ä¹ˆæ—¶å€™ Storeï¼Ÿå“ªäº›æ•°æ®åœ¨å¯„å­˜å™¨ä¸­ï¼Ÿ\nç¼–è¯‘å™¨å¯ä»¥æ›´é«˜æ•ˆåœ°è°ƒåº¦æŒ‡ä»¤ã€å‡å°‘è®¿å­˜æ¬¡æ•°ã€‚\n\nğŸ“– è¿™æ­£æ˜¯ RISC è®¾è®¡å“²å­¦ï¼šâ€œè®©ç¡¬ä»¶ç®€å•ï¼ŒæŠŠå¤æ‚æ€§äº¤ç»™ç¼–è¯‘å™¨ã€‚â€\n\n\nå‡å°‘ç¡¬ä»¶å¤æ‚åº¦ä¸è¯‘ç é€»è¾‘\nCISC æŒ‡ä»¤æ ¼å¼å¤šå˜ã€æ“ä½œæ•°ä½ç½®å¤æ‚ï¼Œ å¯¼è‡´è¯‘ç å•å…ƒå¿…é¡»åŒ…å«ï¼šå¯å˜é•¿åº¦è§£ç å™¨ï¼Œå¤šç§å¯»å€æ¨¡å¼æ”¯æŒï¼Œå†…å­˜æ“ä½œè°ƒåº¦å™¨ã€‚\nLoad/Store æ¶æ„åªéœ€è¦ï¼šå›ºå®šé•¿åº¦æŒ‡ä»¤ï¼ˆå¦‚ RISC-V çš„ 32 ä½å®šé•¿ï¼‰ï¼Œç®€å•å¯»å€ï¼ˆå¯„å­˜å™¨ + ç«‹å³æ•°ï¼‰ï¼Œè¿™ä½¿å¾—ç¡¬ä»¶è¯‘ç é€Ÿåº¦å¿«ï¼Œé¢ç§¯å°ï¼ŒåŠŸè€—ä½ã€‚\n\nè®¿å­˜å»¶è¿Ÿä¸ Cache ä¸ç¡®å®šæ€§\nè®¿å­˜æ“ä½œå¾€å¾€æ˜¯æœ€æ…¢çš„éƒ¨åˆ†ï¼ˆå‡ åç”šè‡³ä¸Šç™¾ä¸ªæ—¶é’Ÿå‘¨æœŸï¼‰ã€‚å¦‚æœå…è®¸ç®—æœ¯æŒ‡ä»¤ç›´æ¥è®¿å­˜ï¼Œé‚£ä¹ˆç®—æœ¯æŒ‡ä»¤æ‰§è¡Œæ—¶é—´å°±ä¼šéšç¼“å­˜å‘½ä¸­ç‡å˜åŒ–ï¼Œéå¸¸ä¸å¯é¢„æµ‹ã€‚\nLoad/Store æœºåˆ¶åˆ™èƒ½ï¼šæŠŠè®¿å­˜å»¶è¿Ÿä¸ç®—æœ¯å»¶è¿Ÿåˆ†ç¦»ï¼›é€šè¿‡ä¹±åºæ‰§è¡Œã€Load-Store é˜Ÿåˆ—ã€Cache Miss é‡å ç­‰æ‰‹æ®µéšè—è®¿å­˜å»¶è¿Ÿã€‚\n\n\n\nğŸ”¹ â€œåˆ†ç¦»å­˜å‚¨è®¿é—®ä¸è®¡ç®—ï¼Œæ˜¯ç°ä»£é«˜æ€§èƒ½å¤„ç†å™¨è®¾è®¡çš„æ ¸å¿ƒåŸåˆ™ã€‚â€\n\nA.2 æ¯ä¸ªæ™¶åœ†ï¼ˆwaferï¼‰ä¸Šå¯åˆ‡å‰²å‡ºçš„èŠ¯ç‰‡ï¼ˆdieï¼‰æ•°å­¦å…¬å¼æ¨å¯¼\næ™¶åœ†ç›´å¾„ï¼š$D$\næ™¶åœ†åŠå¾„ï¼š$R = \\frac{D}{2}$\nå•ä¸ªèŠ¯ç‰‡ï¼ˆdieï¼‰é¢ç§¯ï¼š$A_d$\n\nå¦‚æœæ™¶åœ†æ˜¯å®Œç¾çš„åœ†ï¼Œä¸”å¯ä»¥å®Œå…¨å¡«æ»¡èŠ¯ç‰‡ï¼Œé‚£ä¹ˆï¼š\n\nN_{\\text{ideal}} = \\frac{\\pi R^2}{A_d}å°±æ˜¯ç†è®ºæœ€å¤§èŠ¯ç‰‡æ•°ã€‚\nä½†å®é™…ä¸­ï¼šè¾¹ç¼˜çš„èŠ¯ç‰‡ä¸å®Œæ•´ï¼Œä¸èƒ½ç”¨ï¼›æ™¶åœ†æ˜¯åœ†çš„ï¼ŒèŠ¯ç‰‡æ˜¯æ–¹å½¢çš„ï¼›æ’åˆ—æ–¹å¼ï¼ˆè¡Œåˆ—ï¼‰é€ æˆæµªè´¹ã€‚\næ‰€ä»¥è¦ä¿®æ­£è¾¹ç¼˜æŸå¤±ï¼ˆedge lossï¼‰ã€‚\nç»è¿‡å‡ ä½•è¿‘ä¼¼ï¼ˆç”±Texas Instrumentsæ—©æœŸç ”ç©¶æå‡ºï¼‰ï¼Œå¾—åˆ°å¸¸ç”¨çš„ç»éªŒå…¬å¼ï¼š\n\nN = \\frac{\\pi R^2}{A_d} - \\frac{\\pi D}{\\sqrt{2A_d}}æˆ–ç­‰ä»·å†™æ³•ï¼š\n\nN = \\frac{\\pi (D/2)^2}{A_d} - \\frac{\\pi D}{\\sqrt{2A_d}}æ™¶åœ†è¾¹ç¼˜å‘¨é•¿ä¸º $2\\pi R$ï¼Œå‡è®¾è¾¹ç¼˜é™„è¿‘ä¸€åœˆèŠ¯ç‰‡å¤§æ¦‚ç‡ä¸å®Œæ•´ï¼ˆè¢«åˆ‡æ–­ï¼‰ã€‚\næ¯ä¸ªèŠ¯ç‰‡çš„æœ‰æ•ˆâ€œè¾¹é•¿â€çº¦ä¸º $\\sqrt{A_d}$ã€‚\næ²¿åœ†å‘¨ä¸€åœˆèƒ½æ”¾çš„èŠ¯ç‰‡æ•°é‡çº¦ä¸ºï¼š\n\n\\frac{2\\pi R}{\\sqrt{A_d}}ä½†è¿™äº›èŠ¯ç‰‡ä¸­å¤§çº¦ä¸€åŠé¢ç§¯æµªè´¹æ‰ï¼ˆå¹³å‡çº¦ 50% è¢«åˆ‡å‰²ï¼‰ï¼Œæ‰€ä»¥è¦å‡å»ä¸€åŠèŠ¯ç‰‡æ•°ï¼š\n\nN_{\\text{edge loss}} \\approx \\frac{1}{2} \\cdot \\frac{2\\pi R}{\\sqrt{A_d}} = \\frac{\\pi R}{\\sqrt{A_d}}å°†å…¶å†™æˆç›´å¾„å½¢å¼ $D = 2R$ï¼š\n\nN_{\\text{edge loss}} = \\frac{\\pi D}{2\\sqrt{A_d}} = \\frac{\\pi D}{\\sqrt{2A_d}}ï¼ˆä¸åŒæ–‡çŒ®æœ‰ç•¥å¾®å¸¸æ•°å·®å¼‚ï¼Œæ­¤å¤„ç³»æ•° $\\frac{1}{\\sqrt{2}}$ æ˜¯å‡ ä½•æ‹Ÿåˆç»“æœï¼‰\näºæ˜¯ï¼š\n\nN = N_{\\text{ideal}} - N_{\\text{edge loss}}\n= \\frac{\\pi R^2}{A_d} - \\frac{\\pi D}{\\sqrt{2A_d}}","categories":["ç§‘å­¦æŠ€æœ¯ - è®¡ç®—æœºä½“ç³»ç»“æ„"],"tags":["è®¡ç®—æœºä½“ç³»ç»“æ„","è®¡ç®—æœºä½“ç³»ç»“æ„ - é‡åŒ–ç ”ç©¶æ–¹æ³•","å­¦ä¹ ç¬”è®°"]},{"title":"(7,4) Hamming Code-ç¼–è§£ç å™¨å®ç°ä¸ä»¿çœŸ","url":"/posts/866de32a/","content":"(7,4) Hamming Code - ç¼–è§£ç å™¨å®ç°ä¸ä»¿çœŸ\n    \n    \n    \n        \n    \n    \n        \n    \n    \n        \n    \n\n\n1. ç¼–ç åŸç†æ ¡éªŒä½çš„æ•°é‡å‡è®¾åŸå§‹æ•°æ®å—çš„é•¿åº¦ä¸º $k$ï¼Œæ ¡éªŒä½æ•°ä¸º $r$ï¼Œé‚£ä¹ˆè¦èƒ½å¤Ÿæ£€æµ‹å’Œå®šä½æ‰€æœ‰ 1-bit é”™è¯¯çš„ä½ç½®ï¼Œå¿…é¡»æ»¡è¶³ä»¥ä¸‹ä¸ç­‰å¼ï¼š\n\n2^r \\geq k + r + 1è¿™ä¸ªä¸ç­‰å¼çš„å«ä¹‰æ˜¯ï¼š$2^r$ ç§ä¸åŒçš„æ ¡éªŒç»“æœå¿…é¡»èƒ½å¤Ÿè¡¨ç¤ºï¼š\n\n$k$ ä¸ªæ•°æ®ä½ä¸­å¯èƒ½å‡ºé”™çš„ä»»ä¸€ä½\n$r$ ä¸ªæ ¡éªŒä½ä¸­å¯èƒ½å‡ºé”™çš„ä»»ä¸€ä½\nä»¥åŠæ— é”™è¯¯çš„æƒ…å†µï¼ˆå…± $k + r + 1$ ç§ï¼‰\n\nå¯¹äº 4-bit çš„æ•°æ®ï¼ˆå³ $k = 4$ï¼‰ï¼Œè‡³å°‘ä½¿ç”¨ 3 ä½æ ¡éªŒä½\nHamming(7,4)æ ¡éªŒä½é€šå¸¸æ”¾åœ¨æ•´ä¸ªç å­—ä¸­ç¼–å·ä¸º $2^0, 2^1, 2^2, \\dots$ çš„ä½ç½®ï¼ˆå³ä½ç½® 1, 2, 4, 8,â€¦ï¼‰ã€‚\nindex:   7   6   5   4   3   2   1bit  :  D4  D3  D2  P4  D1  P2  P1å„æ ¡éªŒä½çš„è®¡ç®—æ–¹å¼å¦‚ä¸‹ï¼ˆå¥‡æ ¡éªŒï¼‰:P1 = D1 ^ D2 ^ D4P2 = D1 ^ D3 ^ D4P4 = D2 ^ D3 ^ D4\nç ç‡æ˜¯æŒ‡æ¯ä¸€ä½ç¼–ç ä¸­å®é™…æ‰¿è½½æœ‰æ•ˆä¿¡æ¯çš„æ¯”ä¾‹ï¼š\n\n\\text{ç ç‡} = \\frac{k}{k + r} = \\frac{4}{7} \\approx 0.5712. ç¼–è§£ç å™¨çš„å®ç°hamming74_encoder`timescale 1ns/1psmodule hamming74_encoder (        input  [3:0] data_in,   // d1, d2, d3, d4        output [6:0] code_out   // p1 p2 d1 p3 d2 d3 d4    );    wire p1, p2, p3;    assign p1 = data_in[0] ^ data_in[1] ^ data_in[3];    assign p2 = data_in[0] ^ data_in[2] ^ data_in[3];    assign p3 = data_in[1] ^ data_in[2] ^ data_in[3];    assign code_out = &#123;data_in[3:1], p3, data_in[0], p2, p1&#125;;endmodule\nhamming74_decodermodule hamming74_decoder (        input  [6:0] code_in,       // p1 p2 d1 p3 d2 d3 d4        output [3:0] data_out,      // d1, d2, d3, d4        output       error,         // æœ‰æ— é”™è¯¯        output [6:0] corrected_code // çº é”™åçš„ç å­—    );    wire [2:0] syndrome;    reg  [6:0] corrected_data;    assign syndrome[0] = code_in[0] ^ code_in[2] ^ code_in[4] ^ code_in[6]; // s1    assign syndrome[1] = code_in[1] ^ code_in[2] ^ code_in[5] ^ code_in[6]; // s2    assign syndrome[2] = code_in[3] ^ code_in[4] ^ code_in[5] ^ code_in[6]; // s3    assign error = |syndrome; // æœ‰éé›¶å³æœ‰é”™è¯¯        always @(*) begin        corrected_data = code_in;        if (error) begin            case (syndrome)                3&#x27;b001: corrected_data[0] = ~code_in[0];                3&#x27;b010: corrected_data[1] = ~code_in[1];                3&#x27;b011: corrected_data[2] = ~code_in[2];                3&#x27;b100: corrected_data[3] = ~code_in[3];                3&#x27;b101: corrected_data[4] = ~code_in[4];                3&#x27;b110: corrected_data[5] = ~code_in[5];                3&#x27;b111: corrected_data[6] = ~code_in[6];                default: corrected_data = code_in; // shouldn&#x27;t happen            endcase        end    end    assign corrected_code = corrected_data;    assign data_out = &#123;corrected_data[6], corrected_data[5], corrected_data[4], corrected_data[2]&#125;;endmodule\n3. åŸºäºVerilatorçš„ä»¿çœŸå¼€æºé«˜æ€§èƒ½ä»¿çœŸå™¨Verilator æ˜¯ä¸€æ¬¾åŠŸèƒ½å¼ºå¤§çš„å¼€æº Verilog/SystemVerilog ä»¿çœŸå·¥å…·ï¼Œä¸»è¦ç”¨äºå°† Verilog HDL ä»£ç è½¬æ¢ä¸ºé«˜æ•ˆçš„ C++ æˆ– SystemC ä»£ç ï¼Œä»¥ä¾¿è¿›è¡Œå¿«é€Ÿä»¿çœŸã€‚\n\n\n\n\nç‰¹æ€§\nVerilator\nVCS / ModelSim\n\n\n\n\nç±»å‹\nå‘¨æœŸçº§ä»¿çœŸ\näº‹ä»¶é©±åŠ¨ä»¿çœŸ\n\n\nè®¸å¯\nå¼€æºï¼ˆå…è´¹ï¼‰\nå•†ä¸šæ”¶è´¹\n\n\nè¿è¡Œé€Ÿåº¦\néå¸¸å¿«\nè¾ƒæ…¢ï¼Œä½†ç²¾ç¡®\n\n\nè°ƒè¯•æ–¹å¼\nåŸºæœ¬ trace/VCD\nå¼ºå¤§çš„ GUI æ³¢å½¢è°ƒè¯•\n\n\n\n\nä»¿çœŸåŸç†\n\né¦–å…ˆï¼ŒVerilator å°† Verilog ä»£ç ä¸­å¹¶è¡Œçš„å„ä¸ªé€»è¾‘éƒ¨ä»¶ä»¥åˆé€‚çš„é¡ºåºä¸²è¡ŒåŒ–ï¼Œä½¿ç¡¬ä»¶è®¾è®¡è½¬åŒ–ä¸ºä¸€ä¸ªç±»ä¼¼äºå¤„ç†å™¨æ¨¡æ‹Ÿå™¨çš„è½¯ä»¶ï¼›\næ¥ç€ï¼Œä½¿ç”¨ C/C++ ç¼–å†™æ¿€åŠ±æ–‡ä»¶ã€‚Verilator æä¾›äº†é¡¶å±‚æ¨¡å—è¾“å…¥/è¾“å‡ºå¼•è„šçš„æ¥å£ï¼Œä½¿æˆ‘ä»¬å¾—ä»¥å¯¹é¡¶å±‚æ¨¡å—çš„è¾“å…¥ä¿¡å·èµ‹å€¼æˆ–è¯»å–å…¶è¾“å‡ºä¿¡å·ã€‚ä¸ Vivado ä»¿çœŸä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å®æ—¶åœ°è¾“å‡ºä¸€äº›è°ƒè¯•ä¿¡æ¯ï¼›è¦æŸ¥çœ‹æ³¢å½¢å›¾æ—¶ï¼Œéœ€è¦å¯¼å‡ºæ³¢å½¢æ–‡ä»¶ï¼›\næœ€åï¼ŒVerilator ä¼šç”Ÿæˆä¸€ä¸ª Makefile è„šæœ¬ï¼Œå°†ç”Ÿæˆçš„ C/C++ æ–‡ä»¶å’Œæˆ‘ä»¬ç¼–å†™çš„æ¿€åŠ±æ–‡ä»¶ç¼–è¯‘æˆæˆç”¨äºä»¿çœŸçš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚\n\n\n\næµ‹è¯•æ¡†æ¶æä¾›ç‹¬ç«‹çš„è¿è¡Œç¯å¢ƒï¼Œå®ç° C/C++ å’Œ Verilog çš„å®Œå…¨è§£è€¦ï¼Œæé«˜ä»£ç å¤ç”¨æ€§å’Œå¯ç§»æ¤æ€§ï¼Œå¯ä»¥å…¼å®¹å…¶ä»–ä»¿çœŸè½¯ä»¶ï¼ˆå¦‚ VCSï¼‰ã€‚\n#define VTOP concat(V, TOP_NAME)class TESTBENCH &#123;private:    std::unique_ptr&lt;VerilatedFstC&gt; tfp;    std::unique_ptr&lt;VTOP&gt; top;    std::unique_ptr&lt;VerilatedContext&gt; contextp;public:    TESTBENCH(void);    virtual ~TESTBENCH(void);    virtual void reset(void);    virtual void tick(void);    virtual void eval_and_dump(void);    virtual void sim(void);    virtual bool done(void);&#125;;\næ–°ç‰ˆ Verilator çš„ä¸€äº›ç‰¹æ€§ï¼šè°ƒç”¨ä»¿çœŸç¯å¢ƒcontextpï¼Œæ— éœ€æ‰‹åŠ¨ç»´æŠ¤sim_timeã€‚\nvoid TESTBENCH::eval_and_dump(void) &#123;    contextp-&gt;timeInc(1);    top-&gt;eval();    tfp-&gt;dump(contextp-&gt;time());&#125;void TESTBENCH::sim(void) &#123;    while (!done())        eval_and_dump();&#125;bool TESTBENCH::done(void) &#123; return (Verilated::gotFinish()); &#125;\nç¼–å†™åŸºäº Verilog çš„ testbenchï¼š\n\nVerilator çš„--timingé€‰é¡¹å¯¹å¯ä»¥æ”¯æŒå»¶æ—¶\nç›¸å¯¹äº C/C++ testbenchï¼Œè¿™æ ·å¯ä»¥å…¼å®¹å…¶ä»–ä»¿çœŸè½¯ä»¶\n\n\nå¯¹äº 4 bits çš„æ•°æ®ï¼Œéœ€è¦éªŒè¯ $2^7$ * 7 ç§å•æ¯”ç‰¹é”™è¯¯å¯ä»¥è¢«æˆåŠŸçº æ­£ã€‚\n\nfor (i = 0; i &lt; 16; i = i + 1) begin    data_in = i[3:0];    #1; // ç­‰å¾…ç¼–ç å™¨å·¥ä½œï¼Œå¯¹æ¯ä¸ªæ•°æ®ï¼ŒåŠ 0~7ä½çš„å™ªå£°    for (err = 0; err &lt;= 7; err = err + 1) begin        error_position = err[2:0];        // åŠ å™ªå£°ï¼ˆ0è¡¨ç¤ºä¸åŠ ï¼‰        noisy_code = code_out;        if (error_position != 0)            noisy_code[error_position - 1] = ~code_out[error_position - 1];        #1; // ç­‰å¾…è§£ç å™¨å·¥ä½œ        $write(&quot;%4b  %7b   %1d       %7b   %4b      %1b&quot;,                data_in, code_out, error_position, noisy_code, data_decoded, error_flag);        check(data_in, data_decoded);    endend\nåŠ å…¥ FST æ³¢å½¢è·Ÿè¸ªï¼šFST æ ¼å¼æ¯” VCD æ›´å°æ›´å¿«ï¼ŒåŠ è½½æ›´å¿«ã€å ç”¨æ›´ä½ã€‚éœ€è¦ gtkwave çš„æ”¯æŒã€‚\n#include &lt;verilated_fst_c.h&gt;TESTBENCH::TESTBENCH(void) &#123;    contextp = std::make_unique&lt;VerilatedContext&gt;();    top = std::make_unique&lt;VTOP&gt;(contextp.get());    Verilated::traceEverOn(true);    tfp = std::make_unique&lt;VerilatedFstC&gt;();    top-&gt;trace(tfp.get(), 99);    tfp-&gt;open(TRACE_FILE(TOP_NAME, WAVE_TYPE));&#125;\nä»¿çœŸç»“æœå• bit é”™è¯¯å‡æˆåŠŸæ ¡æ­£ï¼š\n\nä»¿çœŸæ³¢å½¢ç¼–ç å™¨ï¼š\n\nè§£ç å™¨ï¼š\n\n4. ä¸€ä¸ªæœ‰è¶£çš„åº”ç”¨bmp å›¾åƒçš„ä¼ è¾“\nä¸€ä¸ªåŸºäº Hamming(7,4) ç¼–ç çš„å›¾åƒä¼ è¾“ä»¿çœŸç¨‹åºï¼Œæ¨¡æ‹Ÿå›¾åƒåœ¨ä¼ è¾“è¿‡ç¨‹ä¸­å‘ç”Ÿæ¯”ç‰¹é”™è¯¯å¹¶å°è¯•çº æ­£çš„è¿‡ç¨‹ï¼š\n\n\nbmp å¤´éƒ¨ä¿æŠ¤ï¼šæ‹·è´ BMP å›¾åƒæ–‡ä»¶å¤´éƒ¨ 54 å­—èŠ‚ï¼Œç¡®ä¿è¾“å‡ºå›¾åƒä»ä¿æŒåˆæ³•ã€‚\næ•°æ®ç¼–ç ï¼šæ¯ä¸ªå›¾åƒå­—èŠ‚æ‹†åˆ†ä¸ºä¸¤ä¸ª 4 ä½æ•°æ®ï¼Œåˆ†åˆ«ä½¿ç”¨ Hamming(7,4) ç¼–ç ä¸º 7 ä½ç å­—ã€‚\nå™ªå£°æ¨¡æ‹Ÿï¼šæŒ‰è®¾å®šæ¦‚ç‡å¯¹ç¼–ç ä½éšæœºç¿»è½¬ï¼Œæ¨¡æ‹Ÿä¼ è¾“ä¸­çš„æ¯”ç‰¹é”™è¯¯ã€‚\nçº é”™è§£ç ï¼šå°†å«å™ªç å­—é€å…¥è§£ç å™¨ï¼Œè‡ªåŠ¨æ£€æµ‹å¹¶çº æ­£å•æ¯”ç‰¹é”™è¯¯ï¼Œæ¢å¤åŸå§‹æ•°æ®ã€‚\nå›¾åƒè¾“å‡ºï¼šè§£ç ç»“æœé‡ç»„æˆå›¾åƒå¹¶ä¿å­˜ï¼ŒåŒæ—¶è¾“å‡ºä¸€ä»½ä»…åŠ å™ªæœªçº é”™çš„å›¾åƒï¼Œä¾¿äºå¯¹æ¯”æ•ˆæœã€‚\n\n\n\næ¨¡æ‹Ÿä¿¡é“å™ªå£°ï¼š\nNOISE_RATE ?= 5bmp: DEFINES += -DNOISE_RATE=&quot;$(NOISE_RATE)&quot;\nuint8_t invert_mask(int width) &#123;    assert(width &lt;= 8 &amp;&amp; width &gt; 0);    uint8_t mask = 0;    for (int i = 0; i &lt; width; i++) &#123;        if (rand() % 100 &lt; NOISE_RATE)            mask |= (1 &lt;&lt; i);    &#125;    return mask;&#125;\nä¼ è¾“ç»“æœå¯¹æ¯”\nå·¦ä¸ºæœªç»çº é”™çš„å›¾åƒï¼Œå³ä¸ºç»è¿‡ 74 Hamming ç¼–è§£ç å™¨çº é”™çš„å›¾åƒã€‚\n\n$\\text{NOISE RATE} = 1 \\%$\n\n\n    \n    \n\n\n\n$\\text{NOISE RATE} = 5\\%$\n\n\n    \n    \n\n\n$\\text{NOISE RATE} = 10 \\%$\n\n\n    \n    \n\n\n$\\text{NOISE RATE} = 20 \\%$\n\n\n    \n    \n\n\n\næ€»ç»“\nåœ¨ä¿¡é“å™ªå£°è¾ƒä½æ—¶ï¼Œ74 æ±‰æ˜ç æœ‰ä¸é”™çš„çº é”™æ•ˆæœï¼Œå½“å™ªå£°å˜å¤§ï¼Œä¸€ä¸ªå­—èŠ‚ä¸²ä¸­å‡ºç°å¤§é‡çš„ 2 bits å³ä»¥ä¸Šçš„é”™è¯¯æ—¶ï¼Œçº é”™æ•ˆæœæ˜æ˜¾å˜å·®ã€‚\n\n","categories":["ç§‘å­¦æŠ€æœ¯ - ç¡¬ä»¶è®¾è®¡"],"tags":["Verilog","Verilator","çº é”™ç "]}]